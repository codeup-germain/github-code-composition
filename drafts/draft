{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "803ff2d3",
   "metadata": {},
   "source": [
    "# The imports i need "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "bd679286",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "\n",
    "import seaborn as sns\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "import unicodedata\n",
    "import re\n",
    "import json\n",
    "\n",
    "import nltk\n",
    "from nltk.tokenize.toktok import ToktokTokenizer\n",
    "from nltk.corpus import stopwords\n",
    "from nltk import sent_tokenize\n",
    "from prepare import prepare\n",
    "\n",
    "import sklearn.preprocessing\n",
    "import warnings\n",
    "import re\n",
    "\n",
    "from scipy import stats\n",
    "from sklearn.feature_extraction.text import CountVectorizer\n",
    "warnings.filterwarnings('ignore')\n",
    "from sklearn.feature_extraction.text import TfidfVectorizer\n",
    "# imports for modeling\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.tree import DecisionTreeClassifier\n",
    "from sklearn.naive_bayes import MultinomialNB\n",
    "from sklearn.ensemble import RandomForestClassifier\n",
    "from sklearn.naive_bayes import MultinomialNB\n",
    "from sklearn.svm import LinearSVC\n",
    "from sklearn.neighbors import KNeighborsClassifier\n",
    "from sklearn.metrics import classification_report, confusion_matrix, recall_score, plot_confusion_matrix\n",
    "from sklearn.linear_model import LogisticRegression\n",
    "from sklearn import svm\n",
    "from sklearn.linear_model import LinearRegression\n",
    "from sklearn.feature_selection import RFE\n",
    "from model import  vectorizer_split, tfidf_split, test_a_model, make_models_and_print_metrics_test_data, print_metrics"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cda59270",
   "metadata": {},
   "source": [
    "# Josh you shouldnt need the following 3 Cells"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "0bb6ceb3",
   "metadata": {},
   "outputs": [],
   "source": [
    "with open('data.json') as json_file:\n",
    "    data = json.load(json_file)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "b670ba3b",
   "metadata": {},
   "outputs": [],
   "source": [
    "df = pd.DataFrame(data)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "ceb086af",
   "metadata": {},
   "outputs": [],
   "source": [
    "train,validate,test = prepare(df)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0379f7e5",
   "metadata": {},
   "source": [
    "# Josh you can start here"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "53265267",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Baseline Accuracy:C# 31%\n"
     ]
    }
   ],
   "source": [
    "#Create a baseline model\n",
    "#Create a baseline model\n",
    "print(f'Baseline Accuracy:{train.language.value_counts().idxmax()} {round(max(train.language.value_counts()) / train.shape[0] *100)}%' )"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "80deaa2d",
   "metadata": {},
   "source": [
    "The cell above shows C# is the most commonly occuring langauge at 31% this will serve as our baseline"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "25e3ff0f",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Creating a Dataframe to hold all of our scores\n",
    "score_df = pd.DataFrame(columns = ['model_name', 'train_score', 'validate_score'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "0f470ec6",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Creating our y train, validate and test\n",
    "y_train = train.language\n",
    "y_validate = validate.language\n",
    "y_test = test.language\n",
    "# Creating our x train validate and test using a function that \n",
    "# performs count vectorization on stemmed data\n",
    "X_train,X_validate,X_test = vectorizer_split('stemmed')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8cc24fa1",
   "metadata": {},
   "source": [
    "Could not get the following function to work properly when importing "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "7db86aee",
   "metadata": {},
   "outputs": [],
   "source": [
    "def run_models():\n",
    "    #Decision Tree\n",
    "    ## Create a for loop that creates 20 decision tree models with increasingly larger depths.\n",
    "    metrics = []\n",
    "    tree_models = []\n",
    "    for i in range(2, 22):\n",
    "        # Make the model\n",
    "        tree = DecisionTreeClassifier(max_depth=i, random_state=123)\n",
    "\n",
    "        # Fit the model (on train and only train)\n",
    "        tree = tree.fit(X_train, y_train)\n",
    "        y_predictions = tree.predict(X_train)\n",
    "        y_pred = tree.predict(X_validate)\n",
    "        # Use the model\n",
    "        in_sample_accuracy = round(tree.score(X_train, y_train),3)\n",
    "    \n",
    "        out_of_sample_accuracy = round(tree.score(X_validate, y_validate),3)\n",
    "        \n",
    "        in_sample_recall = round(sklearn.metrics.recall_score(y_train, y_predictions, pos_label=0, average='micro'),3)\n",
    "        \n",
    "        out_of_sample_recall = round(sklearn.metrics.recall_score(y_validate, y_pred, pos_label =0, average='micro'),3)\n",
    "        output = {\n",
    "            \"max_depth\": i,\n",
    "            \"train_accuracy\": in_sample_accuracy,\n",
    "            \"validate_accuracy\": out_of_sample_accuracy,\n",
    "            \"train_recall\": in_sample_recall,\n",
    "            \"validate_recall\": out_of_sample_recall\n",
    "        }\n",
    "        \n",
    "        # This creates the df below\n",
    "        metrics.append(output)\n",
    "        # tree_models will store all of my tree models incase i want them later\n",
    "        tree_models.append(tree)\n",
    "        \n",
    "    tree_df = pd.DataFrame(metrics)\n",
    "    tree_df[\"accuracy_difference\"] = tree_df.train_accuracy - tree_df.validate_accuracy    \n",
    "    \n",
    "    # Random Forest\n",
    "    ## Create a for loop that creates 20 Random Forrest models with increasingly larger depths.\n",
    "    metrics2 = []\n",
    "    forest_models = []\n",
    "    for i in range(2, 22):\n",
    "        # Make the model\n",
    "        forest = RandomForestClassifier(max_depth=i, random_state=123)\n",
    "    \n",
    "        # Fit the model (on train and only train)\n",
    "        forest = forest.fit(X_train, y_train)\n",
    "        \n",
    "        y_predictions = forest.predict(X_train)\n",
    "        y_pred = forest.predict(X_validate)\n",
    "        \n",
    "        # Use the model\n",
    "        in_sample_accuracy = round(forest.score(X_train, y_train),3)\n",
    "        \n",
    "        out_of_sample_accuracy = round(forest.score(X_validate, y_validate),3)\n",
    "        \n",
    "        in_sample_recall = round(sklearn.metrics.recall_score(y_train, y_predictions, pos_label =0, average='micro'),3)\n",
    "        \n",
    "        out_of_sample_recall = round(sklearn.metrics.recall_score(y_validate, y_pred, pos_label =0, average='micro'),3)\n",
    "        \n",
    "        output = {\n",
    "            \"max_depth\": i,\n",
    "            \"train_accuracy\": in_sample_accuracy,\n",
    "            \"validate_accuracy\": out_of_sample_accuracy,\n",
    "            \"train_recall\": in_sample_recall,\n",
    "            \"validate_recall\": out_of_sample_recall\n",
    "        }\n",
    "        \n",
    "        # This creates the df below\n",
    "        metrics2.append(output)\n",
    "        # tree_models will store all of my tree models incase i want them later\n",
    "        forest_models.append(forest)\n",
    "        \n",
    "        \n",
    "        \n",
    "    forest_df = pd.DataFrame(metrics2)\n",
    "    forest_df[\"accuracy_difference\"] = forest_df.train_accuracy - forest_df.validate_accuracy\n",
    "    \n",
    "\n",
    "    knn_metrics = []\n",
    "    knn_models = []\n",
    "    # loop through different values of k\n",
    "    for k in range(1, 21):\n",
    "            \n",
    "        # define the thing\n",
    "        knn = KNeighborsClassifier(n_neighbors=k)\n",
    "        \n",
    "        # fit the thing (remmeber only fit on training data)\n",
    "        knn.fit(X_train, y_train)\n",
    "        \n",
    "        y_predictions = knn.predict(X_train)\n",
    "        y_pred = knn.predict(X_validate)\n",
    "        # use the thing (calculate accuracy)\n",
    "        train_accuracy = round(knn.score(X_train, y_train),3)\n",
    "        validate_accuracy = round(knn.score(X_validate, y_validate),3)\n",
    "        train_recall = round(sklearn.metrics.recall_score(y_train, y_predictions, pos_label =0,average='micro'),3)\n",
    "        validate_recall = round(sklearn.metrics.recall_score(y_validate, y_pred, pos_label =0,average='micro'),3)\n",
    "        output = {\n",
    "            \"k\": k,\n",
    "            \"train_accuracy\": train_accuracy,\n",
    "            \"validate_accuracy\": validate_accuracy,\n",
    "            'train_recall':train_recall,\n",
    "            \"validate_recall\":validate_recall\n",
    "        }\n",
    "        \n",
    "        knn_metrics.append(output)\n",
    "        knn_models.append(knn)\n",
    "        # make a dataframe\n",
    "    \n",
    "    knn_df = pd.DataFrame(knn_metrics)\n",
    "    knn_df[\"accuracy_difference\"] = knn_df.train_accuracy - knn_df.validate_accuracy\n",
    "        \n",
    "    \n",
    "    return tree_models, forest_models,knn_models, tree_df, forest_df, knn_df"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "df3ae4e6",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Run multiple variations of KNN, Decision Trees, and Random Forest\n",
    "# with differing variationds of neighbors, branches, and trees\n",
    "# saved those models to the coresponding dataframes so the best \n",
    "# performer could be called upon\n",
    "tree_models, forest_models,knn_models, tree_df, forest_df, knn_df = run_models()\n",
    "\n",
    "from sklearn import svm\n",
    "\n",
    "# make a list of algorithms we want to try for our models\n",
    "model_list = [MultinomialNB(), LinearSVC(), tree_models[tree_df.validate_accuracy.idxmax()], forest_models[forest_df.accuracy_difference.idxmin()], knn_models[knn_df.validate_accuracy.idxmax()], LogisticRegression(), svm.SVC(C= 2, decision_function_shape='ovo')]\n",
    "\n",
    "# name the models\n",
    "model_names = ['Naive_Bayes_stemmed_CV', 'SVC_stemmed_CV', 'Decision_tree_stemmed_CV', 'Random_forest_stemmed_CV', 'KNN_stemmed_CV', 'Log_reg_stemmed_CV','SVC_OVO_stemmed_CV']\n",
    "# Run the models\n",
    "for model, name in zip(model_list, model_names):\n",
    "    score_df = test_a_model(X_train, y_train, X_validate, y_validate, model, name, score_df)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a373c15b",
   "metadata": {},
   "source": [
    "This process is iterative, it will be peromed the exact same way for each variation of stemmed and lemmatized as well as the differing vectorizations of TFIDF and count vectorization. All results are being saved to the data frame score_df. In a seperate notebook each of the models where closely analyzed."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "e4b6f403",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Creating our x train validate and test using a function that \n",
    "# performs count vectorization on lemmatized data\n",
    "X_train,X_validate,X_test = vectorizer_split('lemmatized')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "3dd056da",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Run multiple variations of KNN, Decision Trees, and Random Forest\n",
    "# with differing variationds of neighbors, branches, and trees\n",
    "# saved those models to the coresponding dataframes so the best \n",
    "# performer could be called upon\n",
    "tree_models, forest_models,knn_models, tree_df, forest_df, knn_df = run_models()\n",
    "\n",
    "from sklearn import svm\n",
    "\n",
    "# make a list of algorithms we want to try for our models\n",
    "model_list = [MultinomialNB(), LinearSVC(), tree_models[tree_df.validate_accuracy.idxmax()], forest_models[forest_df.accuracy_difference.idxmin()], knn_models[knn_df.validate_accuracy.idxmax()], LogisticRegression(), svm.SVC(C= 2, decision_function_shape='ovo')]\n",
    "\n",
    "# name the models\n",
    "model_names = ['Naive_Bayes_lemmatized_CV', 'SVC_lemmatized_CV', 'Decision_tree_lemmatized_CV', 'Random_forest_lemmatized_CV', 'KNN_lemmatized_CV', 'Log_reg_lemmatized_CV','SVC_OVO_lemmatized_CV']\n",
    "\n",
    "# Run the models\n",
    "for model, name in zip(model_list, model_names):\n",
    "    score_df = test_a_model(X_train, y_train, X_validate, y_validate, model, name, score_df)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "d2e7e25c",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Creating our x train validate and test using a function that \n",
    "# performs TFIDF vectorization on stemmed data\n",
    "X_train,X_validate,X_test = tfidf_split('stemmed')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "9034634e",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Run multiple variations of KNN, Decision Trees, and Random Forest\n",
    "# with differing variationds of neighbors, branches, and trees\n",
    "# saved those models to the coresponding dataframes so the best \n",
    "# performer could be called upon\n",
    "tree_models, forest_models,knn_models, tree_df, forest_df, knn_df = run_models()\n",
    "\n",
    "from sklearn import svm\n",
    "\n",
    "# make a list of algorithms we want to try for our models\n",
    "model_list = [MultinomialNB(), LinearSVC(), DecisionTreeClassifier(), forest_models[forest_df.accuracy_difference.idxmin()], knn_models[knn_df.validate_accuracy.idxmax()], LogisticRegression(), svm.SVC(C= 2, decision_function_shape='ovo')]\n",
    "\n",
    "# name the models\n",
    "model_names = ['Naive_Bayes_stemmed_TFIDF', 'SVC_stemmed_TFIDF', 'Decision_tree_stemmed_TFIDF', 'Random_forest_stemmed_TFIDF', 'KNN_bigrams_stemmed_TFIDF', 'Log_reg_stemmed_TFIDF','SVC_OVO_stemmed_TFIDF']\n",
    "\n",
    "# Run the models\n",
    "for model, name in zip(model_list, model_names):\n",
    "    score_df = test_a_model(X_train, y_train,X_validate, y_validate, model, name, score_df)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "b31520a0",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Creating our x train validate and test using a function that \n",
    "# performs TFIDF vectorization on lemmatized data\n",
    "X_train,X_validate,X_test = tfidf_split('lemmatized')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "0c6b9c24",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Run multiple variations of KNN, Decision Trees, and Random Forest\n",
    "# with differing variationds of neighbors, branches, and trees\n",
    "# saved those models to the coresponding dataframes so the best \n",
    "# performer could be called upon\n",
    "tree_models, forest_models,knn_models, tree_df, forest_df, knn_df = run_models()\n",
    "\n",
    "from sklearn import svm\n",
    "\n",
    "# make a list of algorithms we want to try for our models\n",
    "model_list = [MultinomialNB(), LinearSVC(), tree_models[tree_df.validate_accuracy.idxmax()], forest_models[forest_df.validate_accuracy.idxmax()], knn_models[knn_df.validate_accuracy.idxmax()], LogisticRegression(), svm.SVC(C= 2, decision_function_shape='ovo')]\n",
    "\n",
    "# name the models\n",
    "model_names = ['Naive_Bayes_lemmatized_TFIDF', 'SVC_lemmatized_TFIDF', 'Decision_tree_lemmatized_TFIDF', 'Random_forest_lemmatized_TFIDF', 'KNN_lemmatized_TFIDF', 'Log_reg_lemmatized_TFIDF','SVC_OVO_lemmatized_TFIDF']\n",
    "\n",
    "# Run the models\n",
    "for model, name in zip(model_list, model_names):\n",
    "    score_df = test_a_model(X_train, y_train, X_validate, y_validate, model, name, score_df)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "6767c29c",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Creating a column to show us the difference between train and validate accuracy \n",
    "score_df[\"accuracy_difference\"] = score_df.train_score - score_df.validate_score"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "c84afeee",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<style  type=\"text/css\" >\n",
       "#T_fef91_row0_col2,#T_fef91_row5_col3{\n",
       "            background-color:  yellow;\n",
       "        }</style><table id=\"T_fef91_\" ><thead>    <tr>        <th class=\"blank level0\" ></th>        <th class=\"col_heading level0 col0\" >model_name</th>        <th class=\"col_heading level0 col1\" >train_score</th>        <th class=\"col_heading level0 col2\" >validate_score</th>        <th class=\"col_heading level0 col3\" >accuracy_difference</th>    </tr></thead><tbody>\n",
       "                <tr>\n",
       "                        <th id=\"T_fef91_level0_row0\" class=\"row_heading level0 row0\" >23</th>\n",
       "                        <td id=\"T_fef91_row0_col0\" class=\"data row0 col0\" >Decision_tree_lemmatized_TFIDF</td>\n",
       "                        <td id=\"T_fef91_row0_col1\" class=\"data row0 col1\" >0.862069</td>\n",
       "                        <td id=\"T_fef91_row0_col2\" class=\"data row0 col2\" >0.720000</td>\n",
       "                        <td id=\"T_fef91_row0_col3\" class=\"data row0 col3\" >0.142069</td>\n",
       "            </tr>\n",
       "            <tr>\n",
       "                        <th id=\"T_fef91_level0_row1\" class=\"row_heading level0 row1\" >5</th>\n",
       "                        <td id=\"T_fef91_row1_col0\" class=\"data row1 col0\" >Log_reg_stemmed_CV</td>\n",
       "                        <td id=\"T_fef91_row1_col1\" class=\"data row1 col1\" >1.000000</td>\n",
       "                        <td id=\"T_fef91_row1_col2\" class=\"data row1 col2\" >0.640000</td>\n",
       "                        <td id=\"T_fef91_row1_col3\" class=\"data row1 col3\" >0.360000</td>\n",
       "            </tr>\n",
       "            <tr>\n",
       "                        <th id=\"T_fef91_level0_row2\" class=\"row_heading level0 row2\" >15</th>\n",
       "                        <td id=\"T_fef91_row2_col0\" class=\"data row2 col0\" >SVC_stemmed_TFIDF</td>\n",
       "                        <td id=\"T_fef91_row2_col1\" class=\"data row2 col1\" >1.000000</td>\n",
       "                        <td id=\"T_fef91_row2_col2\" class=\"data row2 col2\" >0.600000</td>\n",
       "                        <td id=\"T_fef91_row2_col3\" class=\"data row2 col3\" >0.400000</td>\n",
       "            </tr>\n",
       "            <tr>\n",
       "                        <th id=\"T_fef91_level0_row3\" class=\"row_heading level0 row3\" >2</th>\n",
       "                        <td id=\"T_fef91_row3_col0\" class=\"data row3 col0\" >Decision_tree_stemmed_CV</td>\n",
       "                        <td id=\"T_fef91_row3_col1\" class=\"data row3 col1\" >0.913793</td>\n",
       "                        <td id=\"T_fef91_row3_col2\" class=\"data row3 col2\" >0.600000</td>\n",
       "                        <td id=\"T_fef91_row3_col3\" class=\"data row3 col3\" >0.313793</td>\n",
       "            </tr>\n",
       "            <tr>\n",
       "                        <th id=\"T_fef91_level0_row4\" class=\"row_heading level0 row4\" >24</th>\n",
       "                        <td id=\"T_fef91_row4_col0\" class=\"data row4 col0\" >Random_forest_lemmatized_TFIDF</td>\n",
       "                        <td id=\"T_fef91_row4_col1\" class=\"data row4 col1\" >0.913793</td>\n",
       "                        <td id=\"T_fef91_row4_col2\" class=\"data row4 col2\" >0.600000</td>\n",
       "                        <td id=\"T_fef91_row4_col3\" class=\"data row4 col3\" >0.313793</td>\n",
       "            </tr>\n",
       "            <tr>\n",
       "                        <th id=\"T_fef91_level0_row5\" class=\"row_heading level0 row5\" >4</th>\n",
       "                        <td id=\"T_fef91_row5_col0\" class=\"data row5 col0\" >KNN_stemmed_CV</td>\n",
       "                        <td id=\"T_fef91_row5_col1\" class=\"data row5 col1\" >0.465517</td>\n",
       "                        <td id=\"T_fef91_row5_col2\" class=\"data row5 col2\" >0.600000</td>\n",
       "                        <td id=\"T_fef91_row5_col3\" class=\"data row5 col3\" >-0.134483</td>\n",
       "            </tr>\n",
       "            <tr>\n",
       "                        <th id=\"T_fef91_level0_row6\" class=\"row_heading level0 row6\" >6</th>\n",
       "                        <td id=\"T_fef91_row6_col0\" class=\"data row6 col0\" >SVC_OVO_stemmed_CV</td>\n",
       "                        <td id=\"T_fef91_row6_col1\" class=\"data row6 col1\" >0.913793</td>\n",
       "                        <td id=\"T_fef91_row6_col2\" class=\"data row6 col2\" >0.600000</td>\n",
       "                        <td id=\"T_fef91_row6_col3\" class=\"data row6 col3\" >0.313793</td>\n",
       "            </tr>\n",
       "            <tr>\n",
       "                        <th id=\"T_fef91_level0_row7\" class=\"row_heading level0 row7\" >9</th>\n",
       "                        <td id=\"T_fef91_row7_col0\" class=\"data row7 col0\" >Decision_tree_lemmatized_CV</td>\n",
       "                        <td id=\"T_fef91_row7_col1\" class=\"data row7 col1\" >0.982759</td>\n",
       "                        <td id=\"T_fef91_row7_col2\" class=\"data row7 col2\" >0.600000</td>\n",
       "                        <td id=\"T_fef91_row7_col3\" class=\"data row7 col3\" >0.382759</td>\n",
       "            </tr>\n",
       "            <tr>\n",
       "                        <th id=\"T_fef91_level0_row8\" class=\"row_heading level0 row8\" >11</th>\n",
       "                        <td id=\"T_fef91_row8_col0\" class=\"data row8 col0\" >KNN_lemmatized_CV</td>\n",
       "                        <td id=\"T_fef91_row8_col1\" class=\"data row8 col1\" >0.517241</td>\n",
       "                        <td id=\"T_fef91_row8_col2\" class=\"data row8 col2\" >0.600000</td>\n",
       "                        <td id=\"T_fef91_row8_col3\" class=\"data row8 col3\" >-0.082759</td>\n",
       "            </tr>\n",
       "            <tr>\n",
       "                        <th id=\"T_fef91_level0_row9\" class=\"row_heading level0 row9\" >18</th>\n",
       "                        <td id=\"T_fef91_row9_col0\" class=\"data row9 col0\" >KNN_bigrams_stemmed_TFIDF</td>\n",
       "                        <td id=\"T_fef91_row9_col1\" class=\"data row9 col1\" >0.724138</td>\n",
       "                        <td id=\"T_fef91_row9_col2\" class=\"data row9 col2\" >0.560000</td>\n",
       "                        <td id=\"T_fef91_row9_col3\" class=\"data row9 col3\" >0.164138</td>\n",
       "            </tr>\n",
       "    </tbody></table>"
      ],
      "text/plain": [
       "<pandas.io.formats.style.Styler at 0x7f8540968f70>"
      ]
     },
     "execution_count": 17,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Sort the df_scores by the top 10 performing models highlights \n",
    "# the best validation score and the lowest difference between \n",
    "# the two.\n",
    "score_df.sort_values(by='validate_score', ascending=False).head(10).style.highlight_max('validate_score').highlight_min('accuracy_difference')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4c69bcbc",
   "metadata": {},
   "source": [
    "# Key Takeaways\n",
    "- Best performing model was a Decision Tree with a Max depth of 3\n",
    "- Alot of models where over fitting, I tried to limit this but our data might just have some commonalities between them\n",
    "- In a seperate notebook I actually used Recursive Feature Engineering to pick the top features and run them for models that suffer from the curse of dimesionality but that **DID NOT** beat this decision tree model. \n",
    "- Moving foward I feel confident that this is our best performing model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "db5330ff",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "                   ============== Decisiocion Tree ================           \n",
      "DecisionTreeClassifier(max_depth=3, random_state=123)\n",
      "~~~~~~~~Test Scores~~~~~~~~~\n",
      "              precision    recall  f1-score   support\n",
      "\n",
      "          C#       0.36      1.00      0.53         4\n",
      "        HTML       0.75      0.60      0.67         5\n",
      "  JavaScript       1.00      0.40      0.57         5\n",
      "      Python       1.00      0.57      0.73         7\n",
      "\n",
      "    accuracy                           0.62        21\n",
      "   macro avg       0.78      0.64      0.62        21\n",
      "weighted avg       0.82      0.62      0.64        21\n",
      "\n"
     ]
    },
    {
     "data": {
      "image/png": "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nZVkZFQzfbqvs0uyGXfumy2urltbW8uLL77IiBEjGDp0KF988UW97WvXriU+Pt6cOadOnbJYl1uPbJs0aUJOTg4FBQVs3LiRrKws87bGjRtz6NAh9Ho93t7eGAwGjh496sRqLSsqUnDixG+fAqPRicXY0MGDSr76qu7v+l13QXm5iw49GujgQSX9+9f94ejVy8iRI0onV2Q77to3W636tWXLFho3bszixYvRarUkJCTw2GOPmbcfO3aMzMxMOnfubHWbbjGyvRXe3t48/PDDHDhwAID9+/cTHR3t5KpurrZWQU2NApXKREKCgX373OMDbg2jUUFqag0TJtSyf79nfOwuX4ZGjX7711qpBL1nDNrduG8mFArrvm7mySefZPLkyebbSmX938Vjx46RnZ1NcnIyq1atsqoyt/nUHzx40Dxk12g0bNu2zeJzBg0axPbt2wHYtm0bgwcPtneZty042MSIEQaOHvXi+HG3eXuskpWlYtw4XyZNqsXX1z3m/24mOBh0uvr/iXi79f+Kv3Hnvnl5Wfel1WpJTEw0f23atMncRmBgIEFBQeh0OiZNmsSUKVPqvUZ8fDwZGRm89957HD58mD179lisy01+fNC7d+960wSvvfaaxedERkYyZ84ctFot5eXltGrVyp4l3raAABNPP61nxw4lJSWeE7SxsQbCwkx89JE3VVV1o1xPmCKJijLw2WfeJCToOXTIi06dPKBT/8+T+3ZVaGgoeXl5N9x+/vx5nnvuOUaMGFFvoGYymRg1ahTBwcEAxMTEcPz4cWJjY2/6em4TtrdCoVAQExNDRkYG/fv3d3Y5FvXpY8TPD/r2NdK3b92He/NmJXq9e89x/uMfXqSm1pKZWY1SCatXe1Nb6959Ahg8WM/evUoGDAjAZIK33qpydkk24859s8Wc7cWLF/nLX/7CrFmzrpl+1Ol05v+aAwICKCgoICkpyWKbHh22AIMHDyYpKYlXXnnlmm3z5s1jyZIlALRp04bXX3/dwdXVt2uXkl27PGee9qrqagULF6qcXYbNeXlBVla1s8uwC3ftm612kL399tv8+uuvrFixghUrVgAwbNgwrly5glqtJjU1lZSUFFQqFdHR0cTExFiuzWRy9Elr7ikqKoHY2I3OLsPm9u/3vHC/Kj//irNLEA2QkqLh008/ua02evRI4KGHNlv12MuX1TedRrA1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\n",
      "text/plain": [
       "<Figure size 432x288 with 2 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "-------------------------------------------------------------------\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Running the test on unseen data and creating a confusion matrix\n",
    "class_names = ['C#', 'HTML', 'JavaScript','Python' ]\n",
    "make_models_and_print_metrics_test_data(tree_models[tree_df.validate_accuracy.idxmax()], 'Decisiocion Tree', X_train, y_train, X_test, y_test, class_names)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1a0d6f9a",
   "metadata": {},
   "source": [
    "# Conclusion \n",
    "- The Decision Tree model with a max depth of 3 on lemmatized data vectorized by TFIDF was our best performing model\n",
    "- It doubled our baseline of 31% , to 62% accuracy when predicting a repos coding langauge. \n",
    "- C# is the culperate of most misclassifications, perhaps because of commonly used terms between the languages,  with some more cleaning we may be able to improve accuracy.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5e25adcb",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
